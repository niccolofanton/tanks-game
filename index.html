<html>

<head></head>

<body style="margin:0px;"></body>

<script>


    var filed_width = window.innerWidth;
    field_heigth = window.innerHeight;
    max_speed = 6;
    acceleration = 0;
    angular_acceleration = 0;
    max_angular_speed = 0.05;
    tank_width = 100;
    tank_height = 50;
    canvas = document.createElement("canvas");
    ctx = canvas.getContext("2d");
    posX = 200;
    posY = 200;
    angle = 0;
    forward = false;
    backward = false;
    left = false;
    right = false;
    img1 = new Image();
    img1.src = 'tank.png';
    destroyed = false;

    // ---- Bullet 
    var bullet_speed = 15
    max_bounces = 3
    max_bullets = 4
    bullets = []

    canvas.width = filed_width;
    canvas.height = field_heigth;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    document.body.appendChild(canvas);



    var rects = create(10);

    function create(number) {

        var rects = []

        while (rects.length < number) {

            var color = '#' + Math.round(0xffffff * Math.random()).toString(16);
            coordx = Math.random() * canvas.width;
            coordy = Math.random() * canvas.width;
            width = Math.random() * 80 + 20;
            height = Math.random() * 80 + 20;
            rect = {
                color: color,
                x: coordx,
                y: coordy,
                w: width,
                h: height
            }
            ok = true;
            rects.forEach((item) => { if (isCollide(rect, item)) ok = false })

            if (ok) rects.push(rect);

        }

        return rects;

    }

    function isCollide(a, b) {
        return !(
            ((a.y + a.h) < (b.y)) ||
            (a.y > (b.y + b.h)) ||
            ((a.x + a.w) < b.x) ||
            (a.x > (b.x + b.w))
        );
    }

    function toRads(number) {
        return (number + Math.PI) / 180;
    }

    function test(x, y, item_x, item_y, w, h) {

        // ctx.fillStyle = "orange";
        // ctx.fillRect(item_x, item_y, w, h);

        // ctx.fillStyle = "orange";
        // ctx.fillRect(x, y, 5, 5);

        if (
            x >= item_x && x <= item_x + w &&
            y >= item_y && y <= item_y + h
        ) return true
    }


    setInterval(() => {

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        rects.forEach((item) => {
            ctx.fillStyle = item.color;
            ctx.fillRect(item.x, item.y, item.w, item.h);
        })

        var crashed = false;
        var vertex = get_tank_vertex(posX, posY, angle);

        rects.forEach((item) => {
            vertex.forEach(point => {
                if (test(point[0], point[1], item.x, item.y, item.w, item.h))
                    crashed = true;
            })
        })


        if (crashed) {

            if (acceleration != 0) {
                acceleration = Math.round((-acceleration) / 3);
            }
            else if (acceleration < 0) acceleration = 1
            else acceleration = -1

            if (angular_acceleration != 0) {
                angular_acceleration = Math.round((-angular_acceleration) / 3);
            }
            else if (angular_acceleration < 0) angular_acceleration = 0.01
            else angular_acceleration = -0.01

            posX += acceleration * Math.cos(angle);
            posY += acceleration * Math.sin(angle);
        } else {

            if (forward) {
                if (acceleration < max_speed)
                    acceleration += 0.1;
            }

            if (backward) {
                if (acceleration > -max_speed)
                    acceleration -= 0.1;
            }


            if (right) {
                if (angular_acceleration < max_angular_speed)
                    angular_acceleration += 0.005
            }

            if (left) {
                if (angular_acceleration > -max_angular_speed)
                    angular_acceleration -= 0.005
            }



            if (!left && !right) {
                if (angular_acceleration <= 0.06 && angular_acceleration >= -0.06) angular_acceleration = 0
                else if (angular_acceleration < 0) angular_acceleration += 0.02;
                else if (angular_acceleration > 0) angular_acceleration -= 0.02;
            }

            if (!forward && !backward && acceleration != 0) {

                if (acceleration <= 0.6 && acceleration >= -0.6) acceleration = 0
                else if (acceleration < 0) acceleration += 0.5;
                else if (acceleration > 0) acceleration -= 0.5;

            }

            angle += angular_acceleration;
            posX += acceleration * Math.cos(angle);
            posY += acceleration * Math.sin(angle);

        }



        if (posX > filed_width) posX = filed_width;
        if (posX < 0) posX = 0;
        if (posY > field_heigth) posY = field_heigth;
        if (posY < 0) posY = 0;

        // if (angle > toRads(360)) angle = 0
        // if (angle < 0) angle = toRads(360) + angle;

        if (!destroyed) {
            ctx.save();
            ctx.translate(posX, posY);
            ctx.rotate(angle);
            ctx.drawImage(img1, -(tank_width / 2), -(tank_height / 2), tank_width, tank_height);
            ctx.restore();
        }

        for (let i = 0; i < bullets.length; i++) {

            const bullet = bullets[i];

            if (bullet.bounced <= max_bounces) {

                var border = true

                rects.forEach((item) => {
                    ctx.fillStyle = item.color;
                    ctx.fillRect(item.x, item.y, item.w, item.h);

                    if (
                        (bullets[i].x < item.x + item.w) && (bullets[i].x > item.x)
                        && (bullets[i].y < item.y + item.h) && (bullets[i].y > item.y)
                    ) {

                        border = false;
                        bullets[i].bounced++;

                        if (
                            bullet.x > item.x && bullet.x < item.x + bullet_speed ||
                            bullet.x > item.x + item.width - bullet_speed && bullet.x < item.x + item.width
                        )
                            bullets[i].angle = toRads(180) - bullets[i].angle;
                        else bullets[i].angle = -bullets[i].angle

                    }

                })

                if (border) {




                    if ((bullets[i].x < 0) || (bullets[i].x > filed_width)) {
                        console.log(bullet.angle);
                        bullets[i].angle = toRads(180) - bullets[i].angle;
                        bullets[i].bounced++;
                    }

                    if ((bullets[i].y < 0) || (bullets[i].y > field_heigth)) {
                        console.log(bullet.angle);
                        bullets[i].angle = toRads(360) - bullets[i].angle
                        bullets[i].bounced++;
                    }

                }


                if (check_collision(bullet.x, bullet.y, posX, posY, angle, tank_width, tank_height,true)) {
                    destroyed = true;
                }

                bullet.x += bullet_speed * Math.cos(bullet.angle);
                bullet.y += bullet_speed * Math.sin(bullet.angle);

                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(bullet.angle);
                ctx.fillStyle = "white";
                ctx.fillRect(-10, -1.5, 20, 3);
                ctx.restore();


                // bullets[i].tails.push({ x: bullet.x, y: bullet.y, time: 0, angle: bullet.angle })
                // for (let i = 0; i < bullet.tails.length; i++) {

                //     const tail = bullet.tails[i];


                //     if (tail.time > 1000) {
                //         bullet.tails.splice(i, 1)
                //     } else {

                //         if (tail.time > 75) ctx.fillStyle = "yellow";
                //         else if (tail.time > 50) ctx.fillStyle = "orange";
                //         else ctx.fillStyle = "red";

                //         ctx.save();
                //         ctx.translate(tail.x, tail.y);
                //         ctx.rotate(angle);
                //         ctx.fillRect(-25, -1, 50, 2);
                //         ctx.restore();

                //         tail.time++;

                //     }

                // }

            } else {
                bullets.splice(i, 1)
            }

        }


    }, 16)


    // setInterval(() => {

    //     database.ref('tank_1/').update({
    //         x: Math.round(posX),
    //         y: Math.round(posY),
    //         rotation: Math.round(angle)
    //     });

    // }, 100)


    window.addEventListener("keydown", go, true);
    window.addEventListener("keyup", stop, true);
    function go(event) {

        switch (event.keyCode) {
            case 65: left = true; right = false; break;
            case 68: left = false; right = true; break;
            case 87: forward = true; backward = false; break;
            case 83: forward = false; backward = true; break;
            case 32: if (bullets.length < max_bullets) shot(); break;
        }
    }

    function stop(event) {
        switch (event.keyCode) {
            case 87: forward = false; break;
            case 83: backward = false; break;
            case 65: left = false; break;
            case 68: right = false; break;
            // case 32: forward = false; backward = false; break;
        }
    }

    function shot() {

        tempX_2 = (posX + ((tank_width) / 2)) - posX;
        tempX_3 = (posX + ((tank_width) / 2)) - posX;
        tempY_2 = (posY + (tank_height / 2)) - posY;
        tempY_3 = (posY - (tank_height / 2)) - posY;
        rotatedX_2 = tempX_2 * Math.cos(angle) - tempY_2 * Math.sin(angle);
        rotatedX_3 = tempX_3 * Math.cos(angle) - tempY_3 * Math.sin(angle);
        rotatedY_2 = tempX_2 * Math.sin(angle) + tempY_2 * Math.cos(angle);
        rotatedY_3 = tempX_3 * Math.sin(angle) + tempY_3 * Math.cos(angle);

        bullets.push({
            angle: angle,
            tails: [],
            x: posX + ((rotatedX_2 + rotatedX_3) / 2) + acceleration * 2 * Math.cos(angle),
            y: posY + ((rotatedY_2 + rotatedY_3) / 2) + acceleration * 2 * Math.sin(angle),
            bounced: 0
        })

    }

    function collision(bx, by, angle_r, x, y) {

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle_r);
        var tankInvMatrix = ctx.getTransform().invertSelf();
        ctx.restore()

        var bullet = new DOMPoint(bx, by);
        var relBullet = tankInvMatrix.transformPoint(bullet)

        // ctx.save();
        // ctx.translate(x, y);
        // ctx.rotate(angle_r);
        // ctx.fillStyle = "red";
        // ctx.fillRect(- (tank_width / 2), -(tank_height / 2), 2, 2);
        // ctx.fillRect(((tank_width - 50) / 2), (tank_height / 2), 2, 2);
        // ctx.fillRect(- (tank_width / 2), ((tank_height) / 2), 2, 2);
        // ctx.fillRect(((tank_width - 50) / 2), -(tank_height / 2), 2, 2);
        // ctx.restore()

        if (relBullet.x > - (tank_width / 2)
            && relBullet.x < ((tank_width - 50) / 2)
            && relBullet.y > -(tank_height / 2)
            && relBullet.y < (tank_height / 2)) {
            return true
        } else return false

    }


    // if collision is happening

    function check_collision(collision_x, collision_y, x, y, r, w, h, tank_hack) {

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(r);
        var objectInversMatrix = ctx.getTransform().invertSelf();
        ctx.restore()

        var collision_point = new DOMPoint(collision_x, collision_y);
        var relative_collision_point = objectInversMatrix.transformPoint(collision_point)

        if (tank_hack) {
            if (relative_collision_point.x > - (w / 2)
                && relative_collision_point.x < ((w-50) / 2)
                && relative_collision_point.y > -(h / 2)
                && relative_collision_point.y < (h / 2)) {
                return true
            } else return false
        } else {
            if (relative_collision_point.x > - (w / 2)
                && relative_collision_point.x < ((w) / 2)
                && relative_collision_point.y > -(h / 2)
                && relative_collision_point.y < (h / 2)) {
                return true
            } else return false
        }


    }


    function get_tank_vertex(x, y, angle) {
        // tempX_4 = (posX - (tank_width / 2)) - posX;
        // tempX_3 = (posX + ((tank_width - 50) / 2)) - posX;
        // tempY_3 = (posY - (tank_height / 2)) - posY;
        // tempY_4 = (posY + (tank_height / 2)) - posY;
        // rotatedX_1 = xc1 - ys1;
        // rotatedX_2 = xc2 - ys2;
        // rotatedX_3 = xc2 - ys1;
        // rotatedX_4 = xc1 - ys2;
        // rotatedY_1 = xs1 + yc1;
        // rotatedY_2 = xs2 + yc2;
        // rotatedY_3 = xs2 + yc1;
        // rotatedY_4 = xs1 + yc2;

        var
            tempX_1 = (x - (tank_width / 2)) - x;
        tempX_2 = (x + ((tank_width - 50) / 2)) - x;
        tempY_1 = (y - (tank_height / 2)) - y;
        tempY_2 = (y + (tank_height / 2)) - y;
        sin = Math.sin(angle)
        cos = Math.cos(angle)

        xc1 = tempX_1 * cos
        xc2 = tempX_2 * cos
        ys1 = tempY_1 * sin
        ys2 = tempY_2 * sin

        xs1 = tempX_1 * sin
        xs2 = tempX_2 * sin
        yc1 = tempY_1 * cos
        yc2 = tempY_2 * cos

        return [
            [xc1 - ys1 + x, xs1 + yc1 + y],
            [xc2 - ys2 + x, xs2 + yc2 + y],
            [xc2 - ys1 + x, xs2 + yc1 + y],
            [xc1 - ys2 + x, xs1 + yc2 + y]
        ]

    }


    // function calcHitbox(angle, x, y, draw) {

    //     var tempX_1 = (posX - (tank_width / 2)) - posX;
    //     tempX_2 = (posX + ((tank_width - 50) / 2)) - posX;
    //     tempX_3 = (posX + ((tank_width - 50) / 2)) - posX;
    //     tempX_4 = (posX - (tank_width / 2)) - posX;
    //     tempY_1 = (posY - (tank_height / 2)) - posY;
    //     tempY_2 = (posY + (tank_height / 2)) - posY;
    //     tempY_3 = (posY - (tank_height / 2)) - posY;
    //     tempY_4 = (posY + (tank_height / 2)) - posY;

    //     rotatedX_1 = tempX_1 * Math.cos(angle) - tempY_1 * Math.sin(angle);
    //     rotatedX_2 = tempX_2 * Math.cos(angle) - tempY_2 * Math.sin(angle);
    //     rotatedX_3 = tempX_3 * Math.cos(angle) - tempY_3 * Math.sin(angle);
    //     rotatedX_4 = tempX_4 * Math.cos(angle) - tempY_4 * Math.sin(angle);

    //     rotatedY_1 = tempX_1 * Math.sin(angle) + tempY_1 * Math.cos(angle);
    //     rotatedY_2 = tempX_2 * Math.sin(angle) + tempY_2 * Math.cos(angle);
    //     rotatedY_3 = tempX_3 * Math.sin(angle) + tempY_3 * Math.cos(angle);
    //     rotatedY_4 = tempX_4 * Math.sin(angle) + tempY_4 * Math.cos(angle);

    //     if (draw) {
    //         ctx.fillStyle = "green";
    //         ctx.fillRect(rotatedX_1 + posX, rotatedY_1 + posY, 2, 2);

    //         ctx.fillStyle = "yellow";
    //         ctx.fillRect(rotatedX_3 + posX, rotatedY_3 + posY, 2, 2);

    //         ctx.fillStyle = "red";
    //         ctx.fillRect(rotatedX_2 + posX, rotatedY_2 + posY, 2, 2);

    //         ctx.fillStyle = "orange";
    //         ctx.fillRect(rotatedX_4 + posX, rotatedY_4 + posY, 2, 2);
    //     }

    //     return [
    //         [rotatedX_1 + x, rotatedY_1 + y],
    //         [rotatedX_2 + x, rotatedY_2 + y],
    //         [rotatedX_3 + x, rotatedY_3 + y],
    //         [rotatedX_4 + x, rotatedY_4 + y],
    //     ]

    // }

</script>

</html>